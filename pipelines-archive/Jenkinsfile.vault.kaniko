pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: agent
spec:
  serviceAccountName: jenkins
  containers:
  # JNLP container (default Jenkins agent)
  - name: jnlp
    image: jenkins/inbound-agent:latest
    resources:
      requests:
        memory: "256Mi"
        cpu: "200m"
      limits:
        memory: "512Mi"
        cpu: "500m"

  # Kaniko container for building images (NO privileged mode needed!)
  - name: kaniko
    image: gcr.io/kaniko-project/executor:v1.19.0-debug
    command:
    - /busybox/cat
    tty: true
    resources:
      requests:
        memory: "512Mi"
        cpu: "500m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
    volumeMounts:
    - name: kaniko-secret
      mountPath: /kaniko/.docker
    - name: workspace-volume
      mountPath: /workspace

  # Shell container for Vault operations and git
  - name: shell
    image: alpine/git:latest
    command:
    - cat
    tty: true
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"

  # Trivy container for security scanning
  - name: trivy
    image: aquasec/trivy:latest
    command:
    - cat
    tty: true
    resources:
      requests:
        memory: "256Mi"
        cpu: "200m"
      limits:
        memory: "512Mi"
        cpu: "500m"

  volumes:
  - name: kaniko-secret
    secret:
      secretName: harbor-registry-secret
      items:
      - key: .dockerconfigjson
        path: config.json
  - name: workspace-volume
    emptyDir: {}
'''
        }
    }

    environment {
        // Vault configuration
        VAULT_ADDR = 'http://vault.vault.svc.cluster.local:8200'
        VAULT_ROLE = 'jenkins-ci'

        // Harbor registry configuration
        HARBOR_REGISTRY = 'harbor.local'
        HARBOR_PROJECT = 'sample-app'

        // Application versions
        WEBAPP_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/webapp"
        WEBAPI_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/webapi"

        // Git commit info
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        BUILD_TAG = "${env.BUILD_NUMBER}-${GIT_COMMIT_SHORT}"

        // Kubernetes manifest repository
        K8S_REPO = 'https://github.com/chanon-dev/poc-deploy-k8s.git'
        K8S_BRANCH = 'main'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Vault Login') {
            steps {
                container('shell') {
                    script {
                        echo 'Authenticating with Vault using AppRole...'

                        withCredentials([
                            string(credentialsId: 'vault-role-id', variable: 'VAULT_ROLE_ID'),
                            string(credentialsId: 'vault-secret-id', variable: 'VAULT_SECRET_ID')
                        ]) {
                            sh '''
                                # Install curl if not available
                                apk add --no-cache curl 2>/dev/null || true

                                # Login to Vault using AppRole
                                RESPONSE=$(curl -s --request POST \
                                    --data "{\\"role_id\\": \\"${VAULT_ROLE_ID}\\", \\"secret_id\\": \\"${VAULT_SECRET_ID}\\"}" \
                                    ${VAULT_ADDR}/v1/auth/approle/login)

                                # Extract client_token using grep and cut
                                VAULT_TOKEN=$(echo "$RESPONSE" | grep -o '"client_token":"[^"]*' | cut -d'"' -f4)

                                # Validate token
                                if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" = "null" ]; then
                                    echo "âŒ Error: Failed to get Vault token"
                                    echo "Response from Vault:"
                                    echo "$RESPONSE"
                                    exit 1
                                fi

                                # Save token to shared workspace
                                echo "$VAULT_TOKEN" > /workspace/.vault-token
                                echo "âœ… Vault login successful"
                            '''
                        }
                    }
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    echo "Building version: ${BUILD_TAG}"
                    echo "Git commit: ${GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Read Secrets from Vault') {
            steps {
                container('shell') {
                    script {
                        echo 'Reading secrets from Vault...'

                        sh '''
                            # Install curl if not available
                            apk add --no-cache curl 2>/dev/null || true

                            export VAULT_TOKEN=$(cat /workspace/.vault-token)

                            # Read Harbor credentials
                            RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/harbor)
                            HARBOR_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                            HARBOR_PASSWORD=$(echo "$RESPONSE" | grep -o '"password":"[^"]*' | cut -d'"' -f4)

                            # Save to workspace
                            echo "HARBOR_USERNAME=${HARBOR_USERNAME}" > /workspace/.harbor-creds
                            echo "HARBOR_PASSWORD=${HARBOR_PASSWORD}" >> /workspace/.harbor-creds

                            # Read GitHub credentials
                            RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/github)
                            GIT_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                            GIT_TOKEN=$(echo "$RESPONSE" | grep -o '"token":"[^"]*' | cut -d'"' -f4)

                            echo "GIT_USERNAME=${GIT_USERNAME}" > /workspace/.git-creds
                            echo "GIT_TOKEN=${GIT_TOKEN}" >> /workspace/.git-creds

                            # Read build secrets (optional)
                            RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/docker/build-args 2>/dev/null || echo "")
                            NPM_TOKEN=$(echo "$RESPONSE" | grep -o '"npm_token":"[^"]*' | cut -d'"' -f4)

                            if [ ! -z "$NPM_TOKEN" ] && [ "$NPM_TOKEN" != "null" ]; then
                                echo "NPM_TOKEN=${NPM_TOKEN}" > /workspace/.build-secrets
                            fi

                            echo "âœ… Secrets read successfully"
                        '''
                    }
                }
            }
        }

        stage('Build Webapp with Kaniko') {
            steps {
                container('kaniko') {
                    script {
                        echo 'Building Next.js webapp with Kaniko...'

                        sh '''
                            # Source Harbor credentials
                            . /workspace/.harbor-creds

                            # Prepare build args
                            BUILD_ARGS="--build-arg NEXT_PUBLIC_API_URL=http://webapi-service:5000"

                            # Add NPM token if available
                            if [ -f /workspace/.build-secrets ]; then
                                . /workspace/.build-secrets
                                BUILD_ARGS="${BUILD_ARGS} --build-arg NPM_TOKEN=${NPM_TOKEN}"
                            fi

                            # Build and push with Kaniko
                            /kaniko/executor \
                                --context=${WORKSPACE}/app/webapp \
                                --dockerfile=${WORKSPACE}/app/webapp/Dockerfile \
                                --destination=${WEBAPP_IMAGE}:${BUILD_TAG} \
                                --destination=${WEBAPP_IMAGE}:latest \
                                --cache=true \
                                --cache-ttl=24h \
                                --compressed-caching=false \
                                --snapshot-mode=redo \
                                --log-format=text \
                                --verbosity=info \
                                ${BUILD_ARGS}

                            echo "âœ… Webapp image built and pushed successfully"
                        '''
                    }
                }
            }
        }

        stage('Build WebAPI with Kaniko') {
            steps {
                container('kaniko') {
                    script {
                        echo 'Building .NET WebAPI with Kaniko...'

                        sh '''
                            # Build and push with Kaniko
                            /kaniko/executor \
                                --context=${WORKSPACE}/app/webapi \
                                --dockerfile=${WORKSPACE}/app/webapi/Dockerfile \
                                --destination=${WEBAPI_IMAGE}:${BUILD_TAG} \
                                --destination=${WEBAPI_IMAGE}:latest \
                                --cache=true \
                                --cache-ttl=24h \
                                --compressed-caching=false \
                                --snapshot-mode=redo \
                                --log-format=text \
                                --verbosity=info

                            echo "âœ… WebAPI image built and pushed successfully"
                        '''
                    }
                }
            }
        }

        stage('Security Scan') {
            parallel {
                stage('Scan Webapp') {
                    steps {
                        container('trivy') {
                            script {
                                echo 'Scanning webapp image for vulnerabilities...'

                                sh """
                                    # Source Harbor credentials for pulling image
                                    . /workspace/.harbor-creds

                                    # Scan the image
                                    trivy image \
                                        --severity HIGH,CRITICAL \
                                        --exit-code 0 \
                                        --no-progress \
                                        --timeout 10m \
                                        ${WEBAPP_IMAGE}:${BUILD_TAG} || echo "âš ï¸  Vulnerabilities found but continuing..."

                                    echo "âœ… Webapp security scan completed"
                                """
                            }
                        }
                    }
                }

                stage('Scan WebAPI') {
                    steps {
                        container('trivy') {
                            script {
                                echo 'Scanning webapi image for vulnerabilities...'

                                sh """
                                    # Source Harbor credentials for pulling image
                                    . /workspace/.harbor-creds

                                    # Scan the image
                                    trivy image \
                                        --severity HIGH,CRITICAL \
                                        --exit-code 0 \
                                        --no-progress \
                                        --timeout 10m \
                                        ${WEBAPI_IMAGE}:${BUILD_TAG} || echo "âš ï¸  Vulnerabilities found but continuing..."

                                    echo "âœ… WebAPI security scan completed"
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Update K8s Manifests') {
            steps {
                container('shell') {
                    script {
                        echo 'Updating Kubernetes manifests...'

                        sh '''
                            # Source git credentials
                            . /workspace/.git-creds

                            # Clone manifest repository
                            git clone ${K8S_REPO} k8s-manifests
                            cd k8s-manifests

                            # Configure git
                            git config user.name "Jenkins CI"
                            git config user.email "jenkins@example.com"

                            # Update image tags in dev environment
                            sed -i "s|image: harbor.local/sample-app/webapp:.*|image: ${WEBAPP_IMAGE}:${BUILD_TAG}|g" environments/dev/webapp-deployment.yaml
                            sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${WEBAPI_IMAGE}:${BUILD_TAG}|g" environments/dev/webapi-deployment.yaml

                            # Update Vault-enabled deployments if they exist
                            sed -i "s|image: harbor.local/sample-app/webapp:.*|image: ${WEBAPP_IMAGE}:${BUILD_TAG}|g" environments/dev/webapp-deployment.vault.yaml 2>/dev/null || true
                            sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${WEBAPI_IMAGE}:${BUILD_TAG}|g" environments/dev/webapi-deployment.vault.yaml 2>/dev/null || true

                            # Commit and push
                            git add .
                            git commit -m "Update images to version ${BUILD_TAG}

Built by: Jenkins
Job: ${JOB_NAME}
Build: ${BUILD_NUMBER}
Commit: ${GIT_COMMIT_SHORT}

Images:
- ${WEBAPP_IMAGE}:${BUILD_TAG}
- ${WEBAPI_IMAGE}:${BUILD_TAG}" || echo "No changes to commit"

                            git push https://\${GIT_USERNAME}:\${GIT_TOKEN}@github.com/chanon-dev/poc-deploy-k8s.git ${K8S_BRANCH}

                            echo "âœ… Kubernetes manifests updated"
                        '''
                    }
                }
            }
        }

        stage('Trigger Argo CD Sync') {
            steps {
                container('shell') {
                    script {
                        echo 'Triggering Argo CD sync...'

                        sh '''
                            # Install curl if not available
                            apk add --no-cache curl 2>/dev/null || true

                            export VAULT_TOKEN=$(cat /workspace/.vault-token)

                            # Get Argo CD credentials from Vault
                            ARGOCD_TOKEN=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                                ${VAULT_ADDR}/v1/secret/data/ci/argocd | \
                                grep -o '"token":"[^"]*' | cut -d'"' -f4)

                            # Sync webapp application
                            curl -k -X POST \
                                -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                                https://argocd.local/api/v1/applications/webapp-dev/sync || echo "âš ï¸  Webapp sync triggered (might fail if app not exist)"

                            # Sync webapi application
                            curl -k -X POST \
                                -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                                https://argocd.local/api/v1/applications/webapi-dev/sync || echo "âš ï¸  WebAPI sync triggered (might fail if app not exist)"

                            echo "âœ… Argo CD sync triggered"
                        '''
                    }
                }
            }
        }

        stage('Record Build in Vault') {
            steps {
                container('shell') {
                    script {
                        echo 'Recording build metadata in Vault...'

                        sh '''
                            # Install curl if not available
                            apk add --no-cache curl 2>/dev/null || true

                            export VAULT_TOKEN=$(cat /workspace/.vault-token)

                            # Get current timestamp
                            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

                            # Store build metadata
                            curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -X POST \
                                ${VAULT_ADDR}/v1/secret/data/ci/builds/${BUILD_NUMBER} \
                                -d "{\\"data\\": {\\"build_number\\": \\"${BUILD_NUMBER}\\", \\"git_commit\\": \\"${GIT_COMMIT_SHORT}\\", \\"webapp_image\\": \\"${WEBAPP_IMAGE}:${BUILD_TAG}\\", \\"webapi_image\\": \\"${WEBAPI_IMAGE}:${BUILD_TAG}\\", \\"timestamp\\": \\"${TIMESTAMP}\\", \\"build_method\\": \\"kaniko\\"}}" \
                                > /dev/null

                            echo "âœ… Build metadata recorded"
                        '''
                    }
                }
            }
        }
    }

    post {
        success {
            echo "âœ… Pipeline completed successfully!"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Build Method: Kaniko (Production-ready)"
            echo "Webapp image: ${WEBAPP_IMAGE}:${BUILD_TAG}"
            echo "WebAPI image: ${WEBAPI_IMAGE}:${BUILD_TAG}"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        }

        failure {
            echo "âŒ Pipeline failed!"
            echo "Check logs above for details"
        }

        always {
            script {
                container('shell') {
                    // Clean up sensitive files
                    sh """
                        rm -f /workspace/.vault-token /workspace/.harbor-creds /workspace/.git-creds /workspace/.build-secrets 2>/dev/null || true
                        echo "ðŸ§¹ Cleanup completed"
                    """
                }
            }
        }
    }
}

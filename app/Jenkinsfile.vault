pipeline {
    agent any

    environment {
        // Vault configuration
        VAULT_ADDR = 'http://vault.vault.svc.cluster.local:8200'
        VAULT_ROLE = 'jenkins-ci'

        // Harbor registry configuration (will be read from Vault)
        HARBOR_REGISTRY = 'harbor.local'
        HARBOR_PROJECT = 'sample-app'

        // Application versions
        WEBAPP_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/webapp"
        WEBAPI_IMAGE = "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/webapi"

        // Git commit info
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        BUILD_TAG = "${env.BUILD_NUMBER}-${GIT_COMMIT_SHORT}"

        // Kubernetes manifest repository (will be read from Vault)
        K8S_REPO = 'https://github.com/chanon-dev/poc-deploy-k8s.git'
        K8S_BRANCH = 'main'

        // Docker build options
        DOCKER_BUILDKIT = '1'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Vault Login') {
            steps {
                script {
                    echo 'Authenticating with Vault using AppRole...'

                    // Read Vault AppRole credentials from Jenkins (only role_id and secret_id stored in Jenkins)
                    withCredentials([
                        string(credentialsId: 'vault-role-id', variable: 'VAULT_ROLE_ID'),
                        string(credentialsId: 'vault-secret-id', variable: 'VAULT_SECRET_ID')
                    ]) {
                        // Login to Vault and get token
                        sh '''
                            # Login to Vault using AppRole
                            VAULT_TOKEN=$(curl -s --request POST \
                                --data "{\\"role_id\\": \\"${VAULT_ROLE_ID}\\", \\"secret_id\\": \\"${VAULT_SECRET_ID}\\"}" \
                                ${VAULT_ADDR}/v1/auth/approle/login | jq -r '.auth.client_token')

                            # Save token to file (will be used in subsequent stages)
                            echo $VAULT_TOKEN > .vault-token
                        '''
                    }

                    echo 'Successfully authenticated with Vault'
                }
            }
        }

        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm

                script {
                    echo "Build Tag: ${BUILD_TAG}"
                    echo "Git Commit: ${GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Read Secrets from Vault') {
            steps {
                script {
                    echo 'Reading secrets from Vault...'

                    sh '''
                        export VAULT_TOKEN=$(cat .vault-token)

                        # Read Harbor credentials
                        HARBOR_USERNAME=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/harbor | jq -r '.data.data.username')
                        HARBOR_PASSWORD=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/harbor | jq -r '.data.data.password')

                        # Save to environment file (will be sourced in docker login)
                        echo "HARBOR_USERNAME=${HARBOR_USERNAME}" > .harbor-creds
                        echo "HARBOR_PASSWORD=${HARBOR_PASSWORD}" >> .harbor-creds

                        # Read GitHub credentials
                        GIT_USERNAME=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/github | jq -r '.data.data.username')
                        GIT_TOKEN=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/github | jq -r '.data.data.token')

                        echo "GIT_USERNAME=${GIT_USERNAME}" > .git-creds
                        echo "GIT_TOKEN=${GIT_TOKEN}" >> .git-creds

                        # Read build secrets (if any)
                        NPM_TOKEN=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/docker/build-args | jq -r '.data.data.npm_token // empty')

                        if [ ! -z "$NPM_TOKEN" ]; then
                            echo "NPM_TOKEN=${NPM_TOKEN}" > .build-secrets
                        fi
                    '''

                    echo 'Secrets loaded from Vault'
                }
            }
        }

        stage('Build Webapp') {
            steps {
                echo 'Building Next.js Webapp...'
                dir('app/webapp') {
                    script {
                        sh """
                            # Source build secrets if available
                            [ -f ../../.build-secrets ] && source ../../.build-secrets || true

                            docker build \
                                -t ${WEBAPP_IMAGE}:${BUILD_TAG} \
                                -t ${WEBAPP_IMAGE}:latest \
                                --build-arg NEXT_PUBLIC_API_URL=http://webapi-service:5000 \
                                .
                        """
                    }
                }
            }
        }

        stage('Build WebAPI') {
            steps {
                echo 'Building C# WebAPI...'
                dir('app/webapi') {
                    script {
                        sh """
                            docker build \
                                -t ${WEBAPI_IMAGE}:${BUILD_TAG} \
                                -t ${WEBAPI_IMAGE}:latest \
                                .
                        """
                    }
                }
            }
        }

        stage('Security Scan') {
            parallel {
                stage('Scan Webapp') {
                    steps {
                        echo 'Scanning Webapp image for vulnerabilities...'
                        script {
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                    aquasec/trivy:latest image \
                                    --severity HIGH,CRITICAL \
                                    --exit-code 0 \
                                    ${WEBAPP_IMAGE}:${BUILD_TAG} || true
                            """
                        }
                    }
                }

                stage('Scan WebAPI') {
                    steps {
                        echo 'Scanning WebAPI image for vulnerabilities...'
                        script {
                            sh """
                                docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                                    aquasec/trivy:latest image \
                                    --severity HIGH,CRITICAL \
                                    --exit-code 0 \
                                    ${WEBAPI_IMAGE}:${BUILD_TAG} || true
                            """
                        }
                    }
                }
            }
        }

        stage('Push to Harbor') {
            steps {
                echo 'Pushing images to Harbor registry...'
                script {
                    sh '''
                        # Source Harbor credentials
                        source .harbor-creds

                        # Docker login using credentials from Vault
                        echo "${HARBOR_PASSWORD}" | docker login ${HARBOR_REGISTRY} -u "${HARBOR_USERNAME}" --password-stdin

                        # Push Webapp
                        docker push ${WEBAPP_IMAGE}:${BUILD_TAG}
                        docker push ${WEBAPP_IMAGE}:latest

                        # Push WebAPI
                        docker push ${WEBAPI_IMAGE}:${BUILD_TAG}
                        docker push ${WEBAPI_IMAGE}:latest

                        # Logout
                        docker logout ${HARBOR_REGISTRY}
                    '''
                }
            }
        }

        stage('Update Kubernetes Manifests') {
            steps {
                echo 'Updating Kubernetes manifests with new image tags...'
                script {
                    sh """
                        # Source Git credentials
                        source .git-creds

                        # Clone manifest repository
                        rm -rf k8s-manifests
                        git clone ${K8S_REPO} k8s-manifests
                        cd k8s-manifests

                        # Configure git
                        git config user.name "Jenkins CI"
                        git config user.email "jenkins@example.com"

                        # Update webapp deployment
                        sed -i 's|image: ${WEBAPP_IMAGE}:.*|image: ${WEBAPP_IMAGE}:${BUILD_TAG}|' \
                            environments/dev/webapp-deployment.yaml

                        # Update webapi deployment
                        sed -i 's|image: ${WEBAPI_IMAGE}:.*|image: ${WEBAPI_IMAGE}:${BUILD_TAG}|' \
                            environments/dev/webapi-deployment.yaml

                        # Commit and push changes
                        git add .
                        git commit -m "Update images to version ${BUILD_TAG}" || true
                        git push https://\${GIT_USERNAME}:\${GIT_TOKEN}@github.com/chanon-dev/poc-deploy-k8s.git ${K8S_BRANCH}
                    """
                }
            }
        }

        stage('Trigger ArgoCD Sync') {
            steps {
                echo 'Triggering ArgoCD synchronization...'
                script {
                    sh '''
                        export VAULT_TOKEN=$(cat .vault-token)

                        # Read Argo CD token from Vault
                        ARGOCD_TOKEN=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/argocd | jq -r '.data.data.token')

                        # Sync webapp application
                        curl -k -X POST \
                            -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                            -H "Content-Type: application/json" \
                            https://argocd.local/api/v1/applications/sample-webapp/sync

                        # Sync webapi application
                        curl -k -X POST \
                            -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                            -H "Content-Type: application/json" \
                            https://argocd.local/api/v1/applications/sample-webapi/sync
                    '''
                }
            }
        }

        stage('Record Build in Vault') {
            steps {
                echo 'Recording build information in Vault...'
                script {
                    sh '''
                        export VAULT_TOKEN=$(cat .vault-token)

                        # Store build metadata in Vault for audit trail
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            -H "Content-Type: application/json" \
                            -X POST \
                            -d "{\\"data\\": {\\"build_number\\": \\"${BUILD_NUMBER}\\", \\"git_commit\\": \\"${GIT_COMMIT_SHORT}\\", \\"webapp_image\\": \\"${WEBAPP_IMAGE}:${BUILD_TAG}\\", \\"webapi_image\\": \\"${WEBAPI_IMAGE}:${BUILD_TAG}\\", \\"timestamp\\": \\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\"}}" \
                            ${VAULT_ADDR}/v1/secret/data/ci/builds/${BUILD_NUMBER}
                    '''
                }
            }
        }
    }

    post {
        success {
            echo "Pipeline completed successfully!"
            echo "Webapp image: ${WEBAPP_IMAGE}:${BUILD_TAG}"
            echo "WebAPI image: ${WEBAPI_IMAGE}:${BUILD_TAG}"
        }

        failure {
            echo "Pipeline failed!"
        }

        always {
            // Clean up sensitive files
            sh """
                rm -f .vault-token .harbor-creds .git-creds .build-secrets || true

                # Clean up Docker images from Jenkins node
                docker rmi ${WEBAPP_IMAGE}:${BUILD_TAG} || true
                docker rmi ${WEBAPP_IMAGE}:latest || true
                docker rmi ${WEBAPI_IMAGE}:${BUILD_TAG} || true
                docker rmi ${WEBAPI_IMAGE}:latest || true
            """

            cleanWs()
        }
    }
}

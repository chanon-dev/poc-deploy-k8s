// WebAPI Pipeline - .NET 8 API Application
// Build method: Kaniko via kubectl (works with agent any)

pipeline {
    agent any

    parameters {
        string(name: 'HARBOR_REGISTRY', defaultValue: 'harbor.local', description: 'Harbor registry URL')
        string(name: 'HARBOR_PROJECT', defaultValue: 'sample-app', description: 'Harbor project name')
        string(name: 'VAULT_ADDR', defaultValue: 'http://vault.vault.svc.cluster.local:8200', description: 'Vault server address')
        string(name: 'K8S_REPO', defaultValue: 'https://github.com/chanon-dev/poc-deploy-k8s.git', description: 'Kubernetes manifests repository')
        string(name: 'K8S_BRANCH', defaultValue: 'main', description: 'Kubernetes manifests branch')
        string(name: 'ARGOCD_SERVER', defaultValue: 'https://argocd.local', description: 'Argo CD server URL')
        booleanParam(name: 'SKIP_TESTS', defaultValue: true, description: 'Skip test execution (enable when tests are available)')
        booleanParam(name: 'TAG_LATEST', defaultValue: false, description: 'Also tag image as latest (not recommended for production)')
        booleanParam(name: 'FAIL_ON_SCAN_CRITICAL', defaultValue: false, description: 'Fail build if CRITICAL vulnerabilities found')
    }

    environment {
        // Application
        APP_NAME = 'webapi'

        // Configuration from parameters
        VAULT_ADDR = "${params.VAULT_ADDR}"
        HARBOR_REGISTRY = "${params.HARBOR_REGISTRY}"
        HARBOR_PROJECT = "${params.HARBOR_PROJECT}"
        K8S_REPO = "${params.K8S_REPO}"
        K8S_BRANCH = "${params.K8S_BRANCH}"
        ARGOCD_SERVER = "${params.ARGOCD_SERVER}"

        // Image naming
        IMAGE_NAME = "${params.HARBOR_REGISTRY}/${params.HARBOR_PROJECT}/${APP_NAME}"

        // Version
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        BUILD_TAG = "${env.BUILD_NUMBER}-${GIT_COMMIT_SHORT}"
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 20, unit: 'MINUTES')
    }

    stages {
        stage('Vault Login') {
            steps {
                script {
                    echo "ðŸ” Authenticating with Vault..."

                    withCredentials([
                        string(credentialsId: 'vault-role-id', variable: 'VAULT_ROLE_ID'),
                        string(credentialsId: 'vault-secret-id', variable: 'VAULT_SECRET_ID')
                    ]) {
                        retry(3) {
                            sh '''
                                echo "Attempting Vault login..."
                                RESPONSE=$(curl -s --max-time 10 --request POST \
                                    --data "{\\"role_id\\": \\"${VAULT_ROLE_ID}\\", \\"secret_id\\": \\"${VAULT_SECRET_ID}\\"}" \
                                    ${VAULT_ADDR}/v1/auth/approle/login)

                                VAULT_TOKEN=$(echo "$RESPONSE" | grep -o '"client_token":"[^"]*' | cut -d'"' -f4)

                                if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" = "null" ]; then
                                    echo "âŒ Vault login failed. Response: $RESPONSE"
                                    exit 1
                                fi

                                echo "$VAULT_TOKEN" > ${WORKSPACE}/.vault-token
                                echo "âœ… Vault authenticated successfully"
                            '''
                        }
                    }
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    echo "ðŸ“¦ Building ${APP_NAME}:${BUILD_TAG}"
                    echo "ðŸ“ Git commit: ${GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Run Tests') {
            when {
                expression { return !params.SKIP_TESTS }
            }
            steps {
                script {
                    echo "ðŸ§ª Running tests..."

                    sh '''
                        cd apps/${APP_NAME}

                        # Uncomment when tests are available:
                        # dotnet restore
                        # dotnet test --no-build --verbosity normal

                        echo "âš ï¸  Tests skipped - enable by setting SKIP_TESTS=false"
                        echo "âœ… Test stage completed"
                    '''
                }
            }
        }

        stage('Read Secrets') {
            steps {
                script {
                    echo "ðŸ”‘ Reading secrets from Vault..."

                    sh '''
                        VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)
                        export VAULT_TOKEN

                        # GitHub credentials
                        RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/github)
                        GIT_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                        GIT_TOKEN=$(echo "$RESPONSE" | grep -o '"token":"[^"]*' | cut -d'"' -f4)

                        echo "GIT_USERNAME=${GIT_USERNAME}" > ${WORKSPACE}/.git-creds
                        echo "GIT_TOKEN=${GIT_TOKEN}" >> ${WORKSPACE}/.git-creds

                        # Harbor credentials
                        RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/harbor)
                        HARBOR_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                        HARBOR_PASSWORD=$(echo "$RESPONSE" | grep -o '"password":"[^"]*' | cut -d'"' -f4)
                        HARBOR_REGISTRY_URL=$(echo "$RESPONSE" | grep -o '"registry":"[^"]*' | cut -d'"' -f4)

                        # Create Docker config.json for Kaniko
                        mkdir -p ${WORKSPACE}/.docker
                        cat > ${WORKSPACE}/.docker/config.json <<EOF
{
  "auths": {
    "${HARBOR_REGISTRY_URL}": {
      "username": "${HARBOR_USERNAME}",
      "password": "${HARBOR_PASSWORD}",
      "auth": "$(echo -n ${HARBOR_USERNAME}:${HARBOR_PASSWORD} | base64)"
    }
  }
}
EOF

                        echo "âœ… Secrets loaded and Docker config created"
                    '''
                }
            }
        }

        stage('Build with Kaniko') {
            steps {
                script {
                    echo "ðŸ—ï¸  Building ${APP_NAME} with Kaniko..."

                    sh '''
                        # Create kaniko build pod
                        POD_NAME="kaniko-build-${BUILD_NUMBER}"

                        # Create ConfigMap with Docker config
                        kubectl create configmap kaniko-docker-config-${BUILD_NUMBER} \
                            --from-file=${WORKSPACE}/.docker/config.json \
                            -n jenkins \
                            --dry-run=client -o yaml | kubectl apply -f -

                        # Create build context tar
                        cd ${WORKSPACE}/apps/${APP_NAME}
                        tar -czf ${WORKSPACE}/build-context.tar.gz .

                        # Create ConfigMap with build context
                        kubectl create configmap kaniko-context-${BUILD_NUMBER} \
                            --from-file=${WORKSPACE}/build-context.tar.gz \
                            -n jenkins \
                            --dry-run=client -o yaml | kubectl apply -f -

                        # Run Kaniko build pod
                        cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: ${POD_NAME}
  namespace: jenkins
spec:
  restartPolicy: Never
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:v1.23.2
    args:
    - "--dockerfile=Dockerfile"
    - "--context=tar:///workspace/build-context.tar.gz"
    - "--destination=${IMAGE_NAME}:${BUILD_TAG}"
    - "--cache=true"
    - "--cache-ttl=24h"
    volumeMounts:
    - name: docker-config
      mountPath: /kaniko/.docker/
    - name: build-context
      mountPath: /workspace/
  volumes:
  - name: docker-config
    configMap:
      name: kaniko-docker-config-${BUILD_NUMBER}
  - name: build-context
    configMap:
      name: kaniko-context-${BUILD_NUMBER}
EOF

                        echo "Waiting for Kaniko build to complete..."
                        kubectl wait --for=condition=Ready pod/${POD_NAME} -n jenkins --timeout=60s || true

                        # Wait for completion (max 10 minutes)
                        for i in $(seq 1 120); do
                            STATUS=$(kubectl get pod ${POD_NAME} -n jenkins -o jsonpath='{.status.phase}')
                            if [ "$STATUS" = "Succeeded" ]; then
                                echo "âœ… Kaniko build succeeded"
                                kubectl logs ${POD_NAME} -n jenkins
                                break
                            elif [ "$STATUS" = "Failed" ]; then
                                echo "âŒ Kaniko build failed"
                                kubectl logs ${POD_NAME} -n jenkins
                                kubectl delete pod ${POD_NAME} -n jenkins --ignore-not-found
                                kubectl delete configmap kaniko-docker-config-${BUILD_NUMBER} -n jenkins --ignore-not-found
                                kubectl delete configmap kaniko-context-${BUILD_NUMBER} -n jenkins --ignore-not-found
                                exit 1
                            fi
                            sleep 5
                        done

                        # Cleanup
                        kubectl delete pod ${POD_NAME} -n jenkins --ignore-not-found
                        kubectl delete configmap kaniko-docker-config-${BUILD_NUMBER} -n jenkins --ignore-not-found
                        kubectl delete configmap kaniko-context-${BUILD_NUMBER} -n jenkins --ignore-not-found

                        echo "âœ… Image built and pushed: ${IMAGE_NAME}:${BUILD_TAG}"
                    '''
                }
            }
        }

        stage('Security Scan') {
            when {
                expression { return params.FAIL_ON_SCAN_CRITICAL }
            }
            steps {
                script {
                    echo "ðŸ” Scanning image for vulnerabilities..."
                    echo "âš ï¸  Security scan skipped (Trivy not available in default pod)"
                    echo "To enable: install Trivy in pod or use Kubernetes agent with Trivy container"
                }
            }
        }

        stage('Update Manifests') {
            steps {
                script {
                    echo "ðŸ“ Updating Kubernetes manifests..."

                    sh '''
                        . ${WORKSPACE}/.git-creds

                        # Clone manifests repo
                        rm -rf k8s-manifests
                        git clone ${K8S_REPO} k8s-manifests
                        cd k8s-manifests

                        git config user.name "Jenkins CI"
                        git config user.email "jenkins@example.com"

                        # Update deployment
                        sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${IMAGE_NAME}:${BUILD_TAG}|g" manifests/dev/webapi-deployment.yaml
                        sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${IMAGE_NAME}:${BUILD_TAG}|g" manifests/dev/webapi-deployment.vault.yaml 2>/dev/null || true

                        git add manifests/dev/
                        git commit -m "Update webapi to ${BUILD_TAG}

Built by: Jenkins
Job: ${JOB_NAME}
Build: ${BUILD_NUMBER}
Commit: ${GIT_COMMIT_SHORT}" || echo "No changes"

                        git push https://${GIT_USERNAME}:${GIT_TOKEN}@github.com/chanon-dev/poc-deploy-k8s.git ${K8S_BRANCH}

                        echo "âœ… Manifests updated"
                    '''
                }
            }
        }

        stage('Trigger Argo CD') {
            steps {
                script {
                    echo "ðŸš€ Triggering Argo CD sync..."

                    retry(3) {
                        sh '''
                            VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)
                            export VAULT_TOKEN

                            # Get Argo CD token from Vault
                            echo "Retrieving Argo CD token from Vault..."
                            ARGOCD_TOKEN=$(curl -s --max-time 10 \
                                -H "X-Vault-Token: ${VAULT_TOKEN}" \
                                ${VAULT_ADDR}/v1/secret/data/ci/argocd | \
                                grep -o '"token":"[^"]*' | cut -d'"' -f4)

                            if [ -z "$ARGOCD_TOKEN" ]; then
                                echo "âŒ Failed to retrieve Argo CD token"
                                exit 1
                            fi

                            # Sync application
                            echo "Triggering Argo CD sync..."
                            HTTP_CODE=$(curl -k -s -w "%{http_code}" -o /tmp/argocd-response.json \
                                --max-time 30 \
                                -X POST \
                                -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                                ${ARGOCD_SERVER}/api/v1/applications/webapi-dev/sync)

                            if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                                echo "âœ… Argo CD sync triggered successfully (HTTP ${HTTP_CODE})"
                            else
                                echo "âš ï¸  Argo CD sync response (HTTP ${HTTP_CODE}):"
                                cat /tmp/argocd-response.json || true
                            fi

                            echo "âœ… Argo CD notified"
                        '''
                    }
                }
            }
        }

        stage('Record Build') {
            steps {
                script {
                    echo "ðŸ“Š Recording build metadata..."

                    sh '''
                        VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)
                        export VAULT_TOKEN

                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            -H "Content-Type: application/json" \
                            -X POST \
                            ${VAULT_ADDR}/v1/secret/data/ci/builds/webapi/${BUILD_NUMBER} \
                            -d "{\\"data\\": {\\"app\\": \\"webapi\\", \\"build\\": \\"${BUILD_NUMBER}\\", \\"commit\\": \\"${GIT_COMMIT_SHORT}\\", \\"image\\": \\"${IMAGE_NAME}:${BUILD_TAG}\\", \\"timestamp\\": \\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\"}}" \
                            > /dev/null

                        echo "âœ… Build recorded"
                    '''
                }
            }
        }
    }

    post {
        success {
            script {
                echo "âœ… WebAPI deployment successful!"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "ðŸ“¦ Image: ${IMAGE_NAME}:${BUILD_TAG}"
                echo "ðŸ“Š Build metadata recorded in Vault"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            }
        }

        failure {
            echo "âŒ WebAPI deployment failed!"
            echo "Check the logs above for details"
        }

        always {
            script {
                sh '''
                    echo "ðŸ§¹ Cleaning up sensitive files..."
                    rm -rf ${WORKSPACE}/.vault-token ${WORKSPACE}/.git-creds ${WORKSPACE}/.docker ${WORKSPACE}/build-context.tar.gz 2>/dev/null || true
                    echo "âœ… Cleanup completed"
                '''
            }
        }
    }
}

// WebAPI Pipeline - .NET 8 API Application
// Build method: Docker (requires Docker daemon on Jenkins agent)

pipeline {
    agent any

    parameters {
        string(name: 'HARBOR_REGISTRY', defaultValue: 'harbor.local', description: 'Harbor registry URL')
        string(name: 'HARBOR_PROJECT', defaultValue: 'sample-app', description: 'Harbor project name')
        string(name: 'VAULT_ADDR', defaultValue: 'http://vault.vault.svc.cluster.local:8200', description: 'Vault server address')
        string(name: 'K8S_REPO', defaultValue: 'https://github.com/chanon-dev/poc-deploy-k8s.git', description: 'Kubernetes manifests repository')
        string(name: 'K8S_BRANCH', defaultValue: 'main', description: 'Kubernetes manifests branch')
        string(name: 'ARGOCD_SERVER', defaultValue: 'https://argocd.local', description: 'Argo CD server URL')
        booleanParam(name: 'SKIP_TESTS', defaultValue: true, description: 'Skip test execution (enable when tests are available)')
        booleanParam(name: 'TAG_LATEST', defaultValue: false, description: 'Also tag image as latest (not recommended for production)')
        booleanParam(name: 'FAIL_ON_SCAN_CRITICAL', defaultValue: true, description: 'Fail build if CRITICAL vulnerabilities found')
        booleanParam(name: 'SKIP_SECURITY_SCAN', defaultValue: false, description: 'Skip security scan (requires Trivy installed)')
    }

    environment {
        // Application
        APP_NAME = 'webapi'

        // Configuration from parameters
        VAULT_ADDR = "${params.VAULT_ADDR}"
        HARBOR_REGISTRY = "${params.HARBOR_REGISTRY}"
        HARBOR_PROJECT = "${params.HARBOR_PROJECT}"
        K8S_REPO = "${params.K8S_REPO}"
        K8S_BRANCH = "${params.K8S_BRANCH}"
        ARGOCD_SERVER = "${params.ARGOCD_SERVER}"

        // Image naming
        IMAGE_NAME = "${params.HARBOR_REGISTRY}/${params.HARBOR_PROJECT}/${APP_NAME}"

        // Version
        GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
        BUILD_TAG = "${env.BUILD_NUMBER}-${GIT_COMMIT_SHORT}"
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 20, unit: 'MINUTES')
    }

    stages {
        stage('Vault Login') {
            steps {
                script {
                    echo "ðŸ” Authenticating with Vault..."

                    withCredentials([
                        string(credentialsId: 'vault-role-id', variable: 'VAULT_ROLE_ID'),
                        string(credentialsId: 'vault-secret-id', variable: 'VAULT_SECRET_ID')
                    ]) {
                        retry(3) {
                            sh '''
                                echo "Attempting Vault login..."
                                RESPONSE=$(curl -s --max-time 10 --request POST \
                                    --data "{\\"role_id\\": \\"${VAULT_ROLE_ID}\\", \\"secret_id\\": \\"${VAULT_SECRET_ID}\\"}" \
                                    ${VAULT_ADDR}/v1/auth/approle/login)

                                VAULT_TOKEN=$(echo "$RESPONSE" | grep -o '"client_token":"[^"]*' | cut -d'"' -f4)

                                if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" = "null" ]; then
                                    echo "âŒ Vault login failed. Response: $RESPONSE"
                                    exit 1
                                fi

                                echo "$VAULT_TOKEN" > ${WORKSPACE}/.vault-token
                                echo "âœ… Vault authenticated successfully"
                            '''
                        }
                    }
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    echo "ðŸ“¦ Building ${APP_NAME}:${BUILD_TAG}"
                    echo "ðŸ“ Git commit: ${GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Run Tests') {
            when {
                expression { return !params.SKIP_TESTS }
            }
            steps {
                script {
                    echo "ðŸ§ª Running tests..."

                    sh '''
                        cd apps/${APP_NAME}

                        # Uncomment when tests are available:
                        # dotnet restore
                        # dotnet test --no-build --verbosity normal

                        echo "âš ï¸  Tests skipped - enable by setting SKIP_TESTS=false"
                        echo "âœ… Test stage completed"
                    '''
                }
            }
        }

        stage('Read Secrets') {
            steps {
                script {
                    echo "ðŸ”‘ Reading secrets from Vault..."

                    sh '''
                        export VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)

                        # GitHub credentials
                        RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/github)
                        GIT_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                        GIT_TOKEN=$(echo "$RESPONSE" | grep -o '"token":"[^"]*' | cut -d'"' -f4)

                        echo "GIT_USERNAME=${GIT_USERNAME}" > ${WORKSPACE}/.git-creds
                        echo "GIT_TOKEN=${GIT_TOKEN}" >> ${WORKSPACE}/.git-creds

                        # Harbor credentials
                        RESPONSE=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/secret/data/ci/harbor)
                        HARBOR_USERNAME=$(echo "$RESPONSE" | grep -o '"username":"[^"]*' | cut -d'"' -f4)
                        HARBOR_PASSWORD=$(echo "$RESPONSE" | grep -o '"password":"[^"]*' | cut -d'"' -f4)

                        echo "HARBOR_USERNAME=${HARBOR_USERNAME}" >> ${WORKSPACE}/.git-creds
                        echo "HARBOR_PASSWORD=${HARBOR_PASSWORD}" >> ${WORKSPACE}/.git-creds

                        echo "âœ… Secrets loaded"
                    '''
                }
            }
        }

        stage('Build with Docker') {
            steps {
                script {
                    echo "ðŸ—ï¸  Building ${APP_NAME} with Docker..."

                    sh '''
                        source ${WORKSPACE}/.git-creds

                        # Login to Harbor
                        echo "${HARBOR_PASSWORD}" | docker login ${HARBOR_REGISTRY} -u ${HARBOR_USERNAME} --password-stdin

                        # Build image
                        docker build \
                            -t ${IMAGE_NAME}:${BUILD_TAG} \
                            -f apps/${APP_NAME}/Dockerfile \
                            apps/${APP_NAME}

                        echo "âœ… Image built: ${IMAGE_NAME}:${BUILD_TAG}"
                    '''

                    // Optional: Tag as latest
                    if (params.TAG_LATEST) {
                        echo "âš ï¸  Warning: Tagging as 'latest' is enabled"
                        sh "docker tag ${IMAGE_NAME}:${BUILD_TAG} ${IMAGE_NAME}:latest"
                    }
                }
            }
        }

        stage('Push Image') {
            steps {
                script {
                    echo "ðŸ“¤ Pushing image to Harbor..."

                    sh '''
                        source ${WORKSPACE}/.git-creds

                        # Push main tag
                        docker push ${IMAGE_NAME}:${BUILD_TAG}
                        echo "âœ… Pushed: ${IMAGE_NAME}:${BUILD_TAG}"
                    '''

                    if (params.TAG_LATEST) {
                        sh "docker push ${IMAGE_NAME}:latest"
                        echo "âœ… Pushed: ${IMAGE_NAME}:latest"
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                expression { return !params.SKIP_SECURITY_SCAN }
            }
            steps {
                script {
                    echo "ðŸ” Scanning image for vulnerabilities..."

                    def exitCode = params.FAIL_ON_SCAN_CRITICAL ? '1' : '0'
                    def scanMode = params.FAIL_ON_SCAN_CRITICAL ? 'ENFORCING' : 'ADVISORY'

                    echo "Security scan mode: ${scanMode}"
                    echo "Exit code on CRITICAL: ${exitCode}"

                    sh """
                        # Check if Trivy is installed
                        if ! command -v trivy &> /dev/null; then
                            echo "âš ï¸  Trivy not installed - skipping security scan"
                            echo "Install Trivy: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
                            exit 0
                        fi

                        trivy image \
                            --severity HIGH,CRITICAL \
                            --exit-code ${exitCode} \
                            --no-progress \
                            --timeout 10m \
                            ${IMAGE_NAME}:${BUILD_TAG} || {
                                if [ "${exitCode}" = "1" ]; then
                                    echo "âŒ CRITICAL vulnerabilities found - Build FAILED"
                                    exit 1
                                else
                                    echo "âš ï¸  Vulnerabilities found but continuing (advisory mode)"
                                fi
                            }

                        echo "âœ… Security scan completed"
                    """
                }
            }
        }

        stage('Cleanup Local Images') {
            steps {
                script {
                    echo "ðŸ§¹ Cleaning up local Docker images..."

                    sh '''
                        docker rmi ${IMAGE_NAME}:${BUILD_TAG} || true
                    '''

                    if (params.TAG_LATEST) {
                        sh "docker rmi ${IMAGE_NAME}:latest || true"
                    }

                    echo "âœ… Local images cleaned"
                }
            }
        }

        stage('Update Manifests') {
            steps {
                script {
                    echo "ðŸ“ Updating Kubernetes manifests..."

                    sh '''
                        source ${WORKSPACE}/.git-creds

                        # Clone manifests repo
                        rm -rf k8s-manifests
                        git clone ${K8S_REPO} k8s-manifests
                        cd k8s-manifests

                        git config user.name "Jenkins CI"
                        git config user.email "jenkins@example.com"

                        # Update deployment
                        sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${IMAGE_NAME}:${BUILD_TAG}|g" manifests/dev/webapi-deployment.yaml
                        sed -i "s|image: harbor.local/sample-app/webapi:.*|image: ${IMAGE_NAME}:${BUILD_TAG}|g" manifests/dev/webapi-deployment.vault.yaml 2>/dev/null || true

                        git add manifests/dev/
                        git commit -m "Update webapi to ${BUILD_TAG}

Built by: Jenkins
Job: ${JOB_NAME}
Build: ${BUILD_NUMBER}
Commit: ${GIT_COMMIT_SHORT}" || echo "No changes"

                        git push https://${GIT_USERNAME}:${GIT_TOKEN}@github.com/chanon-dev/poc-deploy-k8s.git ${K8S_BRANCH}

                        echo "âœ… Manifests updated"
                    '''
                }
            }
        }

        stage('Trigger Argo CD') {
            steps {
                script {
                    echo "ðŸš€ Triggering Argo CD sync..."

                    retry(3) {
                        sh '''
                            export VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)

                            # Get Argo CD token from Vault
                            echo "Retrieving Argo CD token from Vault..."
                            ARGOCD_TOKEN=$(curl -s --max-time 10 \
                                -H "X-Vault-Token: ${VAULT_TOKEN}" \
                                ${VAULT_ADDR}/v1/secret/data/ci/argocd | \
                                grep -o '"token":"[^"]*' | cut -d'"' -f4)

                            if [ -z "$ARGOCD_TOKEN" ]; then
                                echo "âŒ Failed to retrieve Argo CD token"
                                exit 1
                            fi

                            # Sync application
                            echo "Triggering Argo CD sync..."
                            HTTP_CODE=$(curl -k -s -w "%{http_code}" -o /tmp/argocd-response.json \
                                --max-time 30 \
                                -X POST \
                                -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                                ${ARGOCD_SERVER}/api/v1/applications/webapi-dev/sync)

                            if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                                echo "âœ… Argo CD sync triggered successfully (HTTP ${HTTP_CODE})"
                            else
                                echo "âš ï¸  Argo CD sync response (HTTP ${HTTP_CODE}):"
                                cat /tmp/argocd-response.json || true
                            fi

                            echo "âœ… Argo CD notified"
                        '''
                    }
                }
            }
        }

        stage('Record Build') {
            steps {
                script {
                    echo "ðŸ“Š Recording build metadata..."

                    sh '''
                        export VAULT_TOKEN=$(cat ${WORKSPACE}/.vault-token)

                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
                            -H "Content-Type: application/json" \
                            -X POST \
                            ${VAULT_ADDR}/v1/secret/data/ci/builds/webapi/${BUILD_NUMBER} \
                            -d "{\\"data\\": {\\"app\\": \\"webapi\\", \\"build\\": \\"${BUILD_NUMBER}\\", \\"commit\\": \\"${GIT_COMMIT_SHORT}\\", \\"image\\": \\"${IMAGE_NAME}:${BUILD_TAG}\\", \\"timestamp\\": \\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\"}}" \
                            > /dev/null

                        echo "âœ… Build recorded"
                    '''
                }
            }
        }
    }

    post {
        success {
            script {
                echo "âœ… WebAPI deployment successful!"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo "ðŸ“¦ Image: ${IMAGE_NAME}:${BUILD_TAG}"

                if (params.TAG_LATEST) {
                    echo "ðŸ·ï¸  Also tagged as: ${IMAGE_NAME}:latest"
                    echo "âš ï¸  Note: 'latest' tag is not recommended for production"
                }

                echo "ðŸ“Š Build metadata recorded in Vault"
                echo "ðŸ”’ Security scan: ${params.FAIL_ON_SCAN_CRITICAL ? 'ENFORCING' : 'ADVISORY'} mode"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            }
        }

        failure {
            echo "âŒ WebAPI deployment failed!"
            echo "Check the logs above for details"
        }

        always {
            script {
                sh '''
                    echo "ðŸ§¹ Cleaning up sensitive files..."
                    rm -f ${WORKSPACE}/.vault-token ${WORKSPACE}/.git-creds 2>/dev/null || true

                    # Logout from Docker registry
                    docker logout ${HARBOR_REGISTRY} 2>/dev/null || true

                    echo "âœ… Cleanup completed"
                '''
            }
        }
    }
}
